import { Candle } from '../../tables';
import { stdev } from '../helper';
import { Strategy, StrategyConfig } from '../strategy';

export interface BettingAgainstBetConfig extends StrategyConfig {
  window: number;
  interval: number;
  volatilityWindow: number;
  correlationWindow: number;
}

export class BettingAgainstBetStrategy extends Strategy<BettingAgainstBetConfig> {
  $lastPrice: number = 0;
  $tss: number[] = [];
  $prices: number[] = [];
  $changes: number[] = [];
  $stds: number[] = [];
  $variance: number = 0;

  $firstTs: number = 0;

  constructor(
    name: string,

    config: BettingAgainstBetConfig,
  ) {
    super(name, config);
  }

  async update(candle: Candle): Promise<'long' | 'short' | null> {
    super.update(candle);
    const price = candle.close;

    if (this.$firstTs === 0) {
      this.$firstTs = candle.ts.getTime();
    }

    if (this.$lastPrice !== 0) {
      this.$tss.push(candle.ts.getTime() - this.$firstTs);
      this.$prices.push(price);
    }

    if (this.$tss.length < this.config.requiredLength) {
      return null;
    }

    const returns = this.$prices.slice(this.config.volatilityWindow)
      .map(x => Math.log(x));
    const changes = this.$prices.slice(this.config.correlationWindow)
      .map((x, i) => Math.log(x) - Math.log(this.$prices[i - this.config.interval])).slice(this.config.interval);

    const volatility = stdev(returns);

    if (this.$tss.length > this.config.window) {
      this.$tss.shift();
      this.$prices.shift();
      this.$stds.shift();
    }

    const beta = this.calcBeta(this.$changes, this.$tss);


    this.$lastPrice = price;
  }

  calcBeta(ys: number[], xs: number[]): number {
    let sumX = 0;
    let sumY = 0;
    let sumXY = 0;
    let sumX2 = 0;
    const n = ys.length;

    for (let i = 0; i < n; i++) {
      sumX += xs[i];
      sumY += ys[i];
      sumXY += xs[i] * ys[i];
      sumX2 += xs[i] * xs[i];
    }

    const beta = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    return beta;
  }
}